메모리 구조

스택이 위에서 아래로 쌓임
힙은 아래에서 위로 올라감
함수를 호출하거나 변수를 생성하면 스택을 사용.
동적할당을 하면 힙을 사용.

포인터

포인터는 말그대로 메모리의 주소값이다.
포인터 변수는 메모리의 주소값을 저장하기 위한 변수라고 할 수 있다.
사용하고자 하는 자료형에 따라 포인터 변수를 선언하는 방법이 달라진다.
ex) int*는 int형 변수에 할당된 메모리의 주소를 담을 수 있는 포인터
double*는 double형 변수에 할당된 메모리의 주소를 담을 수 있는 포인터
float*는 float형 변수에 할당된 메모리의 주소를 담을 수 있는 포인터

포인터의 이용

포인터 이름은 주소값을 가진다.
역참조 연산을 통해 해당 주소에 있는 내용물을 가져올 수 있다.
포인터의 포인터는 **로 표시.
ex) int a = 13; int *p = &a; // p는 a의 주소를 가지고 있다.
int **pp = &p; // pp는 p의 주소를 하지고 있다.
*pp = p = &a, **pp = *p = a.

포인터의 이용

포인터에 +, - 연산을 할 경우 해당 포인터가 가리키는 자료형의 크기 * 오른쪽 피연산자만큼 움직인다.
예 int a = 13; int *p = &a;
p + 3: a의 주소에서 int의 크기 * 3만큼 더한 주소를 가리킨다.



배열과 포인터

배열은 포인터 기반으로 동작한다.
배열의 이름은 배열의 0번 원소를 가리키는 포인터.
int arr[4] = {3, 7, 5, 9};
여기에서 arr[2]와 *(arr + 2)는 같다.

함수

하나의 작업을 하는 일련의 명령어들을 모아놓은 것.
같은 작업을 할 때 함수를 구현해두고 호출하면 같은 명령을 반복해서 사용하지 않아도 된다.
호출 시마다 함수 실행코드의 복사본이 스택에 올라가고 인자들을 해당 복사본으로 전송한 후, 돌아올 주소를 전송한다.
그 후 해당 복사본 위치로 점프한다.
함수 수행 이후 반환값을 돌아갈 주소측에 전송한 후 돌아갈 주소로 점프한다.

함수 선언

반환타입 이름(매개변수); //프로토타입 선언

반환타입 이름(매개변수)
{
	내용물;
} //함수 정의
반환 타입에서의 void는 반환값이 없다는 의미이다.

재귀

정의를 할 때 자기 자신을 호출하는 함수를 재귀함수라고 한다.
과도한 재귀는 함수 호출 스택을 꽉 채울 수 있어 주의가 필요하다.

inline

함수 호출시 스택에 쌓지 않고 컴파일 과정에서 실행 코드로 넣음
함수 호출 코드를 해당 함수 실행 코드로 대체함.

함수 포인터

함수도 메모리에 저장되기 때문에 포인터가 존재.
선언 시에 반환타입과 파라미터(매개변수) 타입을 명시.
()은 함수 실행 연산자.
함수 이름 역시 포인터이다.
int (*funcptr)(int); // int를 받아서 int를 반환하는 함수의 포인터.
funcptr = func; funcptr(3);

함수 포인터

함수를 매개변수로 전달할 수 있음.
정렬과 같은 곳에서 조건을 함수 포인터 들을 이용해서 유동적으로 정할 수 있다.
대체제가 있으므로 쓸모 없음.

lambda
익명함수. 한번 쓰고 말 함수의 경우 유용.
또는 auto를 이용하여 저장한 후 사용할 수도 있다.
[사용할 외부변수](파라미터) -> 리턴타입 {실행문}
경우에 따라서 몇 가지를 줄일 수 있다.
auto rightBigger = [](const auto& lhs, const auto& rhs){return lhs < rhs;};
if(rightBigger(3, 5)) cout << "true" << endl;

함수의 아규먼트로 함수 포인터 대신 쓸 수 있다.
ex)
int arr[8] = {4,3,2,5,4,6,7,1};
std::sort(arr, arr + 7,[](auto& lhs, auto& rhs){return lhs < rhs;});