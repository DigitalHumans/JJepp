1. 함수
하나의 작업을 하는 일련의 명령어들을 모아 놓은 것.
같은 작업을 할 때, 함수를 구현해두고 호출하면 같은 명령을 반복해서 사용하지 않아도 됨.
호출할 때마다, 함수 실행 코드의 복사본이 스택에 올라가고, 인자들을 해당 복사본으로 전송한 후, 돌아올 주소를 전송한다.
그 후, 해당 복사본 위치로 점프한다.
함수 수행 이후, 반환 값을 돌아갈 주소 측에 전송한 후, 돌아갈 주소로 점프한다.

1-1. 함수 선언
반환 타입 이름(매개변수);
반환타입 이름(매개변수){
    내용물;
} // 함수 정의

반환 타입에서 void는 반환 값이 없다는 의미.

2. 리커전
정의를 할 때, 자기 자신을 호출하는 함수를 재귀함수하고 한다.
과도한 재귀는 함수 호출 스택을 꽉 채울 수 있어 주의가 필요하다.

3. inline 함수
함수 호출 시, 스택에 쌓지 않고 컴파일 과정에서 실행 코드로 넣음.

4. 함수 포인터
함수도 메모리에 저장되기 때문에 포인터가 존재한다.
선언 시에, 반환 타입과 파라미터 타입을 명시해야 함.
()은 함수 실행 연산자.
함수 이름은 포인터.
함수를 매개변수로 전달 가능.
정렬과 같은 곳에서 조건을 함수 포인터 등을 이용해서 유동적으로 정할 수 있다.
c++에서는 대체제가 있음.

ex)
int(*funcptr)(int);
funcptr = func; funcptr(3);

5. lambda
익명 함수, 한 번 쓰고 다시 안 쓸 함수의 경우 유용.
auto를 이용하여 저장한 후, 사용할 수 있다.
[사용할 외부 변수](파라미터) 키워드 ->리턴타입{실행문}
경우에 따라 몇 가지 생략할 수도 있음.
함수의 아규먼트로 함수 포인터 대신 사용 가능

ex)
auto rightBigger = [](const auto& lhs, const auto& rhs){return lhs < rhs};
if(rightBigger(3, 5)) cout << "true" << endl;

ex')
int arr[8] = {4, 3, 2, 5, 4, 6, 7, 1};
std:: sort(arr, arr + 7,[](auto& lhs, auto& rhs){return lhs < rhs});