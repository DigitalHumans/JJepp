1. 메모리 구조
빈 공간을 스택과 힙이 유동적으로 사용함.
스택과 힙이 서로의 영역을 침범하면 overflow라고 부름.

스택->함수 호출, 변수 생성
힙->동적할당

2. 포인터
메모리의 주소값
메모리의 주소값을 저장하기 위한 변수

ex)
int*: int형 변수에 할당된 메모리의 주소를 담을 수 있는 포인터
double*: double형 변수에 할당된 메모리의 주소를 담을 수 있는 포인터
float*: float형 변수에 할당된 메모리의 주소를 담을 수 있는 포인터

포인터형 변수는 64bit에서는 8byte, 32bit에서는 4byte

2-1. 포인터의 이용
포인터의 이름은 주소값을 가지는 변수.
역참조 연산을 통해 해당 주소에 있는 값을 가져올 수 있음.
포인터의 포인터는 **

ex)
int a = 13; int *p = &a; //p는 a의 주소를 가지고 있다.
int **pp = &p; //pp는 p의 주소를 가지고 있다.
따라서, *pp = p = &a, **pp = *p = a이다.

2-2. 배열과 포인터
배열은 포인터 기반으로 동작.
배열의 이름은 배열의 0번을 가리키는 포인터가 됨.
int arr[4] = {2, 4, 6, 8};
여기에서 arr[2]와 *(arr + 2)는 같다.

3. 레퍼런스
변수 앞에 &을 붙여 레퍼런스로 표기.
해당 객체를 공유.
일반 객체를 사용하는 것처럼 사용하지만 객체를 공유하므로 메모리가 절약됨.
& 대신 &&를 붙이는 rvalue 레퍼런스도 존재.

ex)
int a= 13; int &b = a; b = 24; //a도 24로 바뀜.