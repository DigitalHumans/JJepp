1. 메모리 구조
(프로그램의 실행을 위해 프로그램이 메모리에 load 되어야 함 / 프로그램에서 사용되는 변수를 저장할 메모리 필요)
프로그램이 운영체제로부터 할당받는 메모리 공간 
- 1 코드(code) : 실행할 프로그램의 코드가 저장되는 영역 (텍스트 영역)
- 2 데이터(data) : 프로그램의 전역 변수 / 정적 변수가 저장되는 영역 (*프로그램의 시작과 함께 할당, 프로그램 종료 시 소멸)
- 3 스택(stack) : 지역변수, 매개변수가 저장되는 영역 / 함수의 호출과 함께 할당, 호출 완료 시 소멸 / 스택 영역에 저장되는 함수의 호출 정보 = stack frame
push로 데이터 저장 / pop으로 데이터 인출 (LIFO 방식에 따라 동작) / 높은 주소 > 낮은 주소의 방향으로 할당 
- 4 힙(heap) : 사용자가 직접 관리할 수 있는 메모리 영역 (메모리 공간이 동적으로 할당, 해제) / 낮은 주소 > 높은 주소 방향으로 할당

*** 스택 : 아래 > 위로 쌓임 / 힙 : 위 > 아래로 내려감 
*** 스택과 힙 사이의 빈 공간은 스택과 힙이 유동적으로 사용 (서로의 영역을 침범 X) > 서로의 영역을 침범 : 스택 오버플로우

2. 포인터 (메모리의 주소값)
- 포인터 변수 : 메모리의 주소값을 저장하기 위한 변수 (ex. 변수형*)
- int* : int형 변수에 할당된 메모리의 주소를 담을 수 있는 포인터
- int a=5 / 변수 a의 집주소=int*=ptr
- 포인터 이름 = 주소값을 가짐 / 포인터의 포인터는 **으로 표시
ex) int a=13; int *p=&a; int **pp=&p; 
*pp=p=&a / **pp=*p=a
- 포인터 +- 연산 > 자료형의 크기 * 오른쪽 피연산자만큼 움직임 

3. 배열 
(* 포인터 기반으로 동작) / 배열 이름 = 배열 0번 원소를 가리키는 포인터
ex) int arr[4]={3, 7, 5, 9}
arr[2]=*(arr+2)
- reference : 변수 앞에 &을 붙여 레퍼런스로 표기 (해당 객체 공유) / 메모리 절약 가능
ex) int a=13; int &b=a; b=24; //a=24
Rvalue(오른쪽에 올수있는값) / Lvalue(왼쪽에 올수있는값)
1) Lvalue - 배열타입 / 불완전한 타입 / const 한정자가 붙은 타입 
: 자료형&을 통해서 선언, 다른 lvalue를 통해 초기화 시켜주지 않으면 사용할 수 X
2) Rvalue - 메모리의 위치와 식별자를 특정할 수 없는 데이터 
: 자료형&&을 통해 선언, 일반적인 Lvalue레퍼런스에 대입되지 않는 값들을 참조 